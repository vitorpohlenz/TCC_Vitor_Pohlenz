---
title: "Exeplo PDDE"
author: "Vitor Pohlenz"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```


```{r data}
vmax = 100
vmin = 0
v1 = 55
qmax = 100
pho = 1
tmax = 4

L=80

Nmax = 10 #Numero maximo de interacoes ### OBS: 1 inter = 1fow + 1 back
n = 2 #primeira interacao, usar `n` como debugger 

# y =  list(y1=5,
#           y2 = c(0,60),
#           y3 = c(35,50)
#           )

y = c(5, 30, 45, 40)

termicas = data.frame(nome = c("T1","T2","T3"),
                      ca = c(1,2,5),
                      cl = 0,
                      liminf = 0,
                      limsup = c(30,20,Inf),
                      deltag = c(30,20,Inf)
                      )

volumes = c(v1,NA[2:(tmax+1)]) # Foward

volback = volumes # Backward

# a0 = data.frame(nome = "H", 
#                 ca = 0[1:Nmax] , cl = 0, 
#                 liminf = 0[1:Nmax], limsup =min(v1+y[[1]],vmax)[1:Nmax], 
#                 deltag = min((v1+y[[1]]-0)*pho,qmax*pho) )

at = data.frame(nome = "H", 
                ca = 0[1:Nmax], cl = 0 , 
                liminf = 0[1:Nmax], limsup =vmax[1:Nmax], deltag = min((vmax-0)*pho,qmax*pho) )

a0 = data.frame(nome = "H", 
                ca = 0, cl = 0 , 
                liminf = vmin, limsup =vmax, deltag = min((vmax-vmin)*pho,qmax*pho) )

alpha = list(a1 = at,
             a2 = at,
             a3 = at,
             a4 = a0
             )

# ordem de despacho
ode = list(ode1 = rbind(a0,termicas),
           ode2 = rbind(at,termicas),
           ode3 = rbind(at,termicas),
           ode4 = rbind(at,termicas) # apenas hidro de custo zero
           )

# geracao foward
gera = data.frame(p1 = rep(0,tmax), 
                  p2 = rep(0,tmax), 
                  p3 = rep(0,tmax), 
                  gh = rep(0,tmax)
                  )

gback = gera # Backward

custo = rep(0,tmax) # Custo foward

cusback = custo # Custo backward

# variaveis para somar vazao e volume no mesmo estagio
pot = 0
hidro = a0

# derivada do custo em relacao ao volume e coef linear de alpha e auxiliar de alpha
dfdv = 0
R = 0
dfa = alpha[[1]]
mi = 0
ma = 0
```

# Sistema

- Afluências: `r y`
- Demanda: `r L` MWmês


# Algoritmo

```{r foward, eval=FALSE}
# foward
for (t in 1:tmax) {
  
  ode[[t]] = rbind(na.omit(alpha[[t]]),termicas )
  ode[[t]] = ode[[t]][order(abs(ode[[t]]$ca)),] # Ordem de despacho por merito
  A = y[t] + volumes[t] # Agua disponivel para usar
  
  gera[t,] = 0 #Limpando geracao do foward anterior
  
  pot = ode[[t]] %>% 
          filter(liminf <= A) # Apenas as regioes abaixo da quantia de agua disponivel
                      
  
  # Testa qual é hidro para ajustar liminf
  pot = pot[order(pot$nome, pot$ca),]
  
  if (pot[1,"nome"]=="H") {
    # Pot soh possui nomes com H ou T, e H vem antes do T
    pot[1,"limsup"] = A #Ajustando primeiro limite superior com a quantia de agua
    pot[1,"deltag"] = A - pot[1,"liminf"] 
  }
  
  pot = pot[order(abs(pot$ca),desc(pot$nome)),] # Reordenando por merito e deixando termica antes da hidro
  pot = pot  %>% mutate(deltag = limsup-liminf, # quantia de geracao 
                        soma = cumsum(deltag) ) # Coluna de soma de geracoes
  
  # Quantia de geracao q supre a demanda
  aux = pot$soma<L 
  
  fim = sum(aux)+1
  pot[fim,"soma"] = L
  pot[fim,"deltag"] = ifelse(test = fim==1, 
                             yes = L,
                             no = L- pot[fim-1,"soma"]
                             )
    
  pot = pot[1:fim,] # Definido despacho que supre a demana com as hidros segmentadas
  
  if(pot[fim,"nome"]=="H"){
    pot[fim,"liminf"] = pot$limsup[fim] - pot$deltag[fim]
  }

  hidro = pot %>% filter(nome =="H")
  volumes[t+1] = hidro[nrow(hidro),"liminf"] # Atualizando volumes 
  
  gera[t,"gh"] = sum(hidro$deltag)
  gera[t,"p1"] = pot %>% filter(nome =="T1") %>% pull(deltag) %>% sum()
  gera[t,"p2"] = pot %>% filter(nome =="T2") %>% pull(deltag) %>% sum()
  gera[t,"p3"] = pot %>% filter(nome =="T3") %>% pull(deltag) %>% sum()
  
  custo[t] = as.matrix(gera[t,1:3]) %*% termicas$ca + max(hidro$cl - hidro$ca*volumes[t+1])
}

```

```{r backward,eval=FALSE}
for (t in tmax:2) {
  # Parte foward do bacward
  ode[[t]] = rbind(na.omit(alpha[[t]]),termicas )
  ode[[t]] = ode[[t]][order(abs(ode[[t]]$ca)),] # Ordem de despacho por merito
  A = y[t] + volumes[t] # Agua disponivel para usar
  
  gback[t,] = 0 #Limpando geracao
  
  pot = ode[[t]] %>% 
          filter(liminf <= A) # Apenas as regioes abaixo da quantia de agua disponivel
                    
  
  # Testa qual é hidro para ajustar liminf
  pot = pot[order(pot$nome, pot$ca),]
  
  if (pot[1,"nome"]=="H") {
    # Pot soh possui nomes com H ou T, e H vem antes do T
    pot[1,"limsup"] = A #Ajustando primeiro limite superior com a quantia de agua
    pot[1,"deltag"] = A - pot[1,"liminf"] 
  }
  
  pot = pot[order(abs(pot$ca),desc(pot$nome)),] # Reordenando por merito e deixando termica antes da hidro
  pot = pot  %>% mutate(deltag = limsup-liminf, # quantia de geracao 
                        soma = cumsum(deltag) ) # Coluna de soma de geracoes

  
  # Variacao do custo em relacao ao volume: dfdv = CMO
  auxdf = pot$soma < (L+1) 
  
  dfdv = round(pot[(sum(auxdf)+1),"ca"], digits = 2)
  
  # Quantia de geracao q supre a demanda
  aux = pot$soma<L 
  
  fim = sum(aux)+1
  pot[fim,"soma"] = L
  pot[fim,"deltag"] = ifelse(test = fim==1, 
                             yes = L,
                             no = L- pot[fim-1,"soma"]
                             )
  
  pot = pot[1:fim,] # Definido despacho que supre a demana com as hidros segmentadas
  
  if(pot[fim,"nome"]=="H"){
    pot[fim,"liminf"] = pot$limsup[fim] - pot$deltag[fim]
    }

  hidro = pot %>% filter(nome =="H")
  volback[t+1] = hidro[nrow(hidro),"liminf"] # Atualizando volumes 
  
  gback[t,"gh"] = sum(hidro$deltag)
  gback[t,"p1"] = pot %>% filter(nome =="T1") %>% pull(deltag) %>% sum()
  gback[t,"p2"] = pot %>% filter(nome =="T2") %>% pull(deltag) %>% sum()
  gback[t,"p3"] = pot %>% filter(nome =="T3") %>% pull(deltag) %>% sum()   
  
  cusback[t] = as.matrix(gback[t,1:3]) %*% termicas$ca + max(hidro$cl - hidro$ca*volback[t+1])
  
  R = round(cusback[t] + dfdv*volumes[t], digits = 2)
  
#  alpha[[t-1]][n,"ca"] = dfdv
#  alpha[[t-1]][n,"cl"] = R
  # Arvore de condicoes para atualizar ou n os segmentos de alpha
  dfa = alpha[[t-1]] %>%
          mutate(vl = round((R-cl)/(dfdv-ca),digits = 2),
                 li = liminf,
                 ls = limsup,
                 ik = 0,
                 sk = 0,
                 vway = case_when(!is.na(vl) & (vl>=li & vl<=ls) ~ 1,
                                  !is.na(vl) & (vl<li | vl>ls) & !is.infinite(vl) ~ 2,
                                  is.na(vl) ~ 3,
                                  is.infinite(vl) ~ 4
                                  ),
                 natu = case_when(vway == 2 & (vl < li & dfdv > ca) ~ T,
                                  vway == 2 & (vl > ls & dfdv < ca) ~ T,
                                  vway == 3 ~ T,
                                  vway == 4 & vl < 0 ~ T,
                                  TRUE ~ F
                                  ),
                 exold = case_when(vway == 2 & (vl < li & dfdv < ca) ~ T,
                                   vway == 2 & (vl > ls & dfdv > ca) ~ T,
                                   vway == 4 & vl > 0 ~ T,
                                   TRUE ~ F
                                   ),
                 liminf = case_when(vway == 1 & dfdv > ca ~ vl,
                                    TRUE ~ li
                                    ),
                 limsup = case_when(vway == 1 & dfdv < ca ~ vl,
                                    TRUE ~ ls
                                    ),
                 ca = case_when(exold ~ as.numeric(NA),
                                TRUE ~ ca
                                ),
                 cl = case_when(exold ~ as.numeric(NA),
                                TRUE ~ cl
                                ),
                 
                 ik = case_when(vway == 1 & dfdv > ca ~ li,
                                exold ~ li,
                                TRUE ~ vl
                                ),                 
                 sk = case_when(vway == 1 & dfdv < ca ~ ls,
                                exold ~ ls,
                                TRUE ~ vl
                                )                 
                 )
  if(!all(dfa$natu)){ # Se pelo menos um segmento for atualizado o novo segmento eh adcionado
  
    # Limite inferior e superior do novo segmento, que deve ser o min e max dos valores antigos
    alpha[[t-1]] = dfa %>% select(names(alpha[[t-1]]))
    alpha[[t-1]][n,"ca"] = dfdv
    alpha[[t-1]][n,"cl"] = R
    
    alpha[[t-1]][n,"liminf"] = min(dfa$ik,na.rm = T)
    alpha[[t-1]][n,"limsup"] = max(dfa$sk,na.rm = T) 
    
    alpha[[t-1]] = alpha[[t-1]] %>% within(ca[liminf==limsup] <- NA_real_ )
    
    
  }
  
 
  
   
}

```

```{r pdde}
for (n in 2:Nmax){
  # foward
  for (t in 1:tmax) {
  
    ode[[t]] = rbind(na.omit(alpha[[t]]),termicas )
    ode[[t]] = ode[[t]][order(abs(ode[[t]]$ca)),] # Ordem de despacho por merito
    A = y[t] + volumes[t] # Agua disponivel para usar
    
    gera[t,] = 0 #Limpando geracao do foward anterior
    
    pot = ode[[t]] %>% 
            filter(liminf <= A) # Apenas as regioes abaixo da quantia de agua disponivel
                        
    
    # Testa qual é hidro para ajustar liminf
    pot = pot[order(pot$nome, pot$ca),]
    
    if (pot[1,"nome"]=="H") {
      # Pot soh possui nomes com H ou T, e H vem antes do T
      pot[1,"limsup"] = A #Ajustando primeiro limite superior com a quantia de agua
      pot[1,"deltag"] = A - pot[1,"liminf"] 
    }
    
    pot = pot[order(abs(pot$ca),desc(pot$nome)),] # Reordenando por merito e deixando termica antes da hidro
    pot = pot  %>% mutate(deltag = limsup-liminf, # quantia de geracao 
                          soma = cumsum(deltag) ) # Coluna de soma de geracoes
    
    # Quantia de geracao q supre a demanda
    aux = pot$soma<L 
    
    fim = sum(aux)+1
    pot[fim,"soma"] = L
    pot[fim,"deltag"] = ifelse(test = fim==1, 
                               yes = L,
                               no = L- pot[fim-1,"soma"]
                               )
      
    pot = pot[1:fim,] # Definido despacho que supre a demana com as hidros segmentadas
    
    if(pot[fim,"nome"]=="H"){
      pot[fim,"liminf"] = pot$limsup[fim] - pot$deltag[fim]
    }
  
    hidro = pot %>% filter(nome =="H")
    volumes[t+1] = hidro[nrow(hidro),"liminf"] # Atualizando volumes 
    
    gera[t,"gh"] = sum(hidro$deltag)
    gera[t,"p1"] = pot %>% filter(nome =="T1") %>% pull(deltag) %>% sum()
    gera[t,"p2"] = pot %>% filter(nome =="T2") %>% pull(deltag) %>% sum()
    gera[t,"p3"] = pot %>% filter(nome =="T3") %>% pull(deltag) %>% sum()
    
    custo[t] = as.matrix(gera[t,1:3]) %*% termicas$ca + max(hidro$cl - hidro$ca*volumes[t+1])
    
  }
  
  #Backward
  for (t in tmax:2) {
    # Parte foward do bacward
    ode[[t]] = rbind(na.omit(alpha[[t]]),termicas )
    ode[[t]] = ode[[t]][order(abs(ode[[t]]$ca)),] # Ordem de despacho por merito
    A = y[t] + volumes[t] # Agua disponivel para usar
    
    gback[t,] = 0 #Limpando geracao
    
    pot = ode[[t]] %>% 
            filter(liminf <= A) # Apenas as regioes abaixo da quantia de agua disponivel
                      
    
    # Testa qual é hidro para ajustar liminf
    pot = pot[order(pot$nome, pot$ca),]
    
    if (pot[1,"nome"]=="H") {
      # Pot soh possui nomes com H ou T, e H vem antes do T
      pot[1,"limsup"] = A #Ajustando primeiro limite superior com a quantia de agua
      pot[1,"deltag"] = A - pot[1,"liminf"] 
    }
    
    pot = pot[order(abs(pot$ca),desc(pot$nome)),] # Reordenando por merito e deixando termica antes da hidro
    pot = pot  %>% mutate(deltag = limsup-liminf, # quantia de geracao 
                          soma = cumsum(deltag) ) # Coluna de soma de geracoes
  
    
    # Variacao do custo em relacao ao volume: dfdv = CMO
    auxdf = pot$soma < (L+1) 
    
    dfdv = round(pot[(sum(auxdf)+1),"ca"], digits = 2)
    
    # Quantia de geracao q supre a demanda
    aux = pot$soma<L 
    
    fim = sum(aux)+1
    pot[fim,"soma"] = L
    pot[fim,"deltag"] = ifelse(test = fim==1, 
                               yes = L,
                               no = L- pot[fim-1,"soma"]
                               )
    
    pot = pot[1:fim,] # Definido despacho que supre a demana com as hidros segmentadas
    
    if(pot[fim,"nome"]=="H"){
      pot[fim,"liminf"] = pot$limsup[fim] - pot$deltag[fim]
      }
  
    hidro = pot %>% filter(nome =="H")
    volback[t+1] = hidro[nrow(hidro),"liminf"] # Atualizando volumes 
    
    gback[t,"gh"] = sum(hidro$deltag)
    gback[t,"p1"] = pot %>% filter(nome =="T1") %>% pull(deltag) %>% sum()
    gback[t,"p2"] = pot %>% filter(nome =="T2") %>% pull(deltag) %>% sum()
    gback[t,"p3"] = pot %>% filter(nome =="T3") %>% pull(deltag) %>% sum()   
    
    cusback[t] = as.matrix(gback[t,1:3]) %*% termicas$ca + max(hidro$cl - hidro$ca*volback[t+1])
    
    R = round(cusback[t] + dfdv*volumes[t], digits = 2)
    
  #  alpha[[t-1]][n,"ca"] = dfdv
  #  alpha[[t-1]][n,"cl"] = R
    # Arvore de condicoes para atualizar ou n os segmentos de alpha
    dfa = alpha[[t-1]] %>%
            mutate(vl = (R-cl)/(dfdv-ca),
                   li = liminf,
                   ls = limsup,
                   ik = 0,
                   sk = 0,
                   vway = case_when(!is.na(vl) & (vl>=li & vl<=ls) ~ 1,
                                    !is.na(vl) & (vl<li | vl>ls) & !is.infinite(vl) ~ 2,
                                    is.na(vl) ~ 3,
                                    is.infinite(vl) ~ 4
                                    ),
                   natu = case_when(vway == 2 & (vl < li & dfdv > ca) ~ T,
                                    vway == 2 & (vl > ls & dfdv < ca) ~ T,
                                    vway == 3 ~ T,
                                    vway == 4 & vl < 0 ~ T,
                                    TRUE ~ F
                                    ),
                   exold = case_when(vway == 2 & (vl < li & dfdv < ca) ~ T,
                                     vway == 2 & (vl > ls & dfdv > ca) ~ T,
                                     vway == 4 & vl > 0 ~ T,
                                     TRUE ~ F
                                     ),
                   liminf = case_when(vway == 1 & dfdv > ca ~ vl,
                                      TRUE ~ li
                                      ),
                   limsup = case_when(vway == 1 & dfdv < ca ~ vl,
                                      TRUE ~ ls
                                      ),
                   ca = case_when(exold ~ as.numeric(NA),
                                  TRUE ~ ca
                                  ),
                   cl = case_when(exold ~ as.numeric(NA),
                                  TRUE ~ cl
                                  ),
                   
                   ik = case_when(vway == 1 & dfdv > ca ~ li,
                                  exold ~ li,
                                  TRUE ~ vl
                                  ),                 
                   sk = case_when(vway == 1 & dfdv < ca ~ ls,
                                  exold ~ ls,
                                  TRUE ~ vl
                                  )                 
                   )
    if(!all(dfa$natu)){ # Se pelo menos um segmento for atualizado o novo segmento eh adcionado
    
      # Limite inferior e superior do novo segmento, que deve ser o min e max dos valores antigos
      alpha[[t-1]] = dfa %>% select(names(alpha[[t-1]]))
      alpha[[t-1]][n,"ca"] = dfdv
      alpha[[t-1]][n,"cl"] = R
      
      alpha[[t-1]][n,"liminf"] = min(dfa$ik,na.rm = T)
      alpha[[t-1]][n,"limsup"] = max(dfa$sk,na.rm = T) 
      
      alpha[[t-1]] = alpha[[t-1]] %>% within(ca[liminf==limsup] <- NA_real_ )
      
      
    }
    
   
    
     
  }

}

```


```{r resp}

```


